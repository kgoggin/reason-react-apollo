<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Using the Generated Types for Your Schema · Reason GraphQL Tools</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="After configuring and running the codegen against your GraphQL schema, you&#x27;ll now have access to a ReasonML type that corresponds to each of the GraphQL types defined in your schema. Be convention, these types are defined in a file called `Graphql.re`. Within that file, each of your types is added as its own module. Let&#x27;s take a look at an example schema:"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Using the Generated Types for Your Schema · Reason GraphQL Tools"/><meta property="og:type" content="website"/><meta property="og:url" content="https://your-docusaurus-test-site.com/"/><meta property="og:description" content="After configuring and running the codegen against your GraphQL schema, you&#x27;ll now have access to a ReasonML type that corresponds to each of the GraphQL types defined in your schema. Be convention, these types are defined in a file called `Graphql.re`. Within that file, each of your types is added as its own module. Let&#x27;s take a look at an example schema:"/><meta property="og:image" content="https://your-docusaurus-test-site.com/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://your-docusaurus-test-site.com/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/undefined"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/prism.css"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><h2 class="headerTitle">Reason GraphQL Tools</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Getting Started</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>API</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/setting-up-codegen">Setting Up Your Project for Codegen</a></li><li class="navListItem"><a class="navItem" href="/docs/setting-up-apollo">Creating an Apollo Client</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/docs/working-with-the-types">Using the Generated Types for Your Schema</a></li><li class="navListItem"><a class="navItem" href="/docs/using-queries">Working With Queries</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Using the Generated Types for Your Schema</h1></header><article><div><span><p>After configuring and running the codegen against your GraphQL schema, you'll now have access to a ReasonML type that corresponds to each of the GraphQL types defined in your schema. Be convention, these types are defined in a file called <code>Graphql.re</code>. Within that file, each of your types is added as its own module. Let's take a look at an example schema:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">scalar</span> <span class="token class-name">DateTIme</span>

<span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token attr-name">name</span><span class="token punctuation">:</span> String<span class="token operator">!</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Todo</span> <span class="token punctuation">{</span>
  <span class="token attr-name">id</span><span class="token punctuation">:</span> ID<span class="token operator">!</span>
  <span class="token attr-name">title</span><span class="token punctuation">:</span> String<span class="token operator">!</span>
  <span class="token attr-name">isComplete</span><span class="token punctuation">:</span> Boolean<span class="token operator">!</span>
  <span class="token attr-name">dueDate</span><span class="token punctuation">:</span> DateTime
  <span class="token attr-name">assignee</span><span class="token punctuation">:</span> User
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">todos</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Todo<span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This GraphQL schema defines thee types: <code>User</code>, <code>Todo</code>, and <code>Query</code>. The resulting ReasonML code would contain types <code>Graphql.Todo.t</code> and <code>Graphql.Query.t</code>. You can now use these types throughout your project. You might have a component that renders all todos that takes an <code>array(Graphql.Todo.t)</code>, and a detail component that takes a single todo - these underlying types are now shareable throughout your project, and it's easy to tell what a given function or component is working with just by the type signature.</p>
<h2><a class="anchor" aria-hidden="true" id="accessing-fields-on-a-type"></a><a href="#accessing-fields-on-a-type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accessing Fields on a Type</h2>
<p>The generated types are &quot;abstract&quot; types, similar to those you create using <code>[@bs.deriving abstract]</code>. That means the implementation of the type is hidden from the consumer, so you can't access fields on the type directly. Instead, fields are accessed via getter functions that take an object of that type as their only argument. So, to access a <code>Todo</code>'s title, for example, you'd use its getter like this:</p>
<pre><code class="hljs css language-reason"><span class="token keyword">let</span> title <span class="token operator">=</span> todo<span class="token operator">-></span><span class="token class-name">Graphql</span><span class="token punctuation">.</span><span class="token class-name">Todo</span><span class="token punctuation">.</span>title<span class="token punctuation">;</span>
</code></pre>
<p>Each type's fields have a getter function available in its module, and if your language server is working correctly you should see each field available via autocomplete.</p>
<h3><a class="anchor" aria-hidden="true" id="why-abstract-types"></a><a href="#why-abstract-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why Abstract Types?</h3>
<p>The use of abstract types with getter functions is a design decision to allow for a runtime check that the field you're asking for exists on the object you're working with. GraphQL's dynamic nature means that an object fetched via a query may have only one of its fields, or could have all of them, depending on what was queried. One way to handle this would be to type every single field as <code>Js.Undefined.t</code>, but this gets really cumbersome to work with. Another way would be to type each query individually (which is how graphql-ppx works), but then you lose the ability to have a single definition of your GraphQL schema type that you can share around your project.</p>
<p>So, these bindings assume every field exists, but makes you ask for it with a getter function. As a part of the getter's execution, it will verify that the object in question actually does have the field you're asking for, and throw an error (with a helpful error message) if it's absent.</p>
<h2><a class="anchor" aria-hidden="true" id="nested-fields"></a><a href="#nested-fields" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nested Fields</h2>
<p>When accessing deeply nested fields, just chain the getters together. And, since the getters are just functions, they work really well with some of the other functional programming paradigms in Reason:</p>
<pre><code class="hljs css language-reason"><span class="token keyword">let</span> firstAssignee<span class="token punctuation">:</span> option<span class="token punctuation">(</span><span class="token class-name">Graphql</span><span class="token punctuation">.</span><span class="token class-name">User</span><span class="token punctuation">.</span>t<span class="token punctuation">)</span> <span class="token operator">=</span>
  queryResponse
    <span class="token operator">-></span><span class="token class-name">Graphql</span><span class="token punctuation">.</span><span class="token class-name">Query</span><span class="token punctuation">.</span>todos
    <span class="token operator">-></span><span class="token class-name">Belt</span><span class="token punctuation">.</span><span class="token class-name">Array</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token operator">-></span><span class="token class-name">Belt</span><span class="token punctuation">.</span><span class="token class-name">Option</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span><span class="token class-name">Graphql</span><span class="token punctuation">.</span><span class="token class-name">Todo</span><span class="token punctuation">.</span>assignedTo<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="input-types"></a><a href="#input-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Input Types</h2>
<p>Input types in GraphQL are used as the arguments for queries and mutations. These types get their own module generated as well, but instead of getter functions, these modules include a <code>make</code> function, with labeled arguments for each of the type's fields. So, for an input like this:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">input</span> CreateTodo <span class="token punctuation">{</span>
  <span class="token attr-name">title</span><span class="token punctuation">:</span> String<span class="token operator">!</span>
  <span class="token attr-name">isComplete</span><span class="token punctuation">:</span> Boolean
<span class="token punctuation">}</span>
</code></pre>
<p>You could create an instance of this type like this:</p>
<pre><code class="hljs css language-reason"><span class="token keyword">let</span> createdTodo <span class="token operator">=</span> <span class="token class-name">Graphql</span><span class="token punctuation">.</span><span class="token class-name">CreateTodo</span><span class="token punctuation">.</span>make<span class="token punctuation">(</span><span class="token operator">~</span>title<span class="token operator">=</span><span class="token string">"Do a thing"</span><span class="token punctuation">,</span> <span class="token operator">~</span>isComplete<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Queries and mutations that accept input types as arguments are typed to use the result of these functions.</p>
<h2><a class="anchor" aria-hidden="true" id="enums"></a><a href="#enums" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Enums</h2>
<p>GraphQL <code>enum</code> types map to a Reason polymorphic variant. They don't get their own module, but they do get a special &quot;enum map&quot; record that makes it easy to map them to and from strings. Let's look at another example:</p>
<pre><code class="hljs css language-graphql"><span class="token keyword">enum</span> <span class="token class-name">FILTER</span> <span class="token punctuation">{</span>
  <span class="token constant">COMPLETE</span>
  <span class="token constant">INCOMPLETE</span>
  <span class="token constant">ALL</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The generated Reason type will be called <code>filter_enum</code> (to avoid naming collisions with regular types), and you'll also have access to <code>filterMap</code>. These look like this:</p>
<pre><code class="hljs css language-reason"><span class="token keyword">type</span> filter_enum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">|</span> <span class="token operator">`</span><span class="token constructor variable">COMPLETE</span> <span class="token operator">|</span> <span class="token operator">`</span><span class="token constructor variable">INCOMPLETE</span> <span class="token operator">|</span> <span class="token operator">`</span><span class="token constructor variable">ALL</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> filterMap <span class="token operator">=</span> <span class="token punctuation">{</span>
  toString<span class="token punctuation">:</span> filter_enum <span class="token operator">=></span> string<span class="token punctuation">,</span>
  fromString<span class="token punctuation">:</span> string <span class="token operator">=></span> option<span class="token punctuation">(</span>filter_enum<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>The to/from string functions can be helpful when trying to interop with JS code, but note that enums are always represented as the variant type when accessing them as a field on a normal type, or passing them as an argument to make an input type. In most cases you can always treat them as a variant and never worry about them actually being a string!</p>
<h2><a class="anchor" aria-hidden="true" id="scalars"></a><a href="#scalars" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scalars</h2>
<p>If your GraphQL schema contains scalar definitions (like <code>DateTime</code> above) you'll need to specify a backing ReasonML type for it in your codegen config. It can be a type included with Reason, such as a <code>string</code>, or one you've defined in your project somewhere else, like <code>DateTime.t</code>. Thank's to Reason's module system, the generated code will just work, and you can type your scalars in whatever way works best for your project.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/setting-up-apollo"><span class="arrow-prev">← </span><span>Creating an Apollo Client</span></a><a class="docs-next button" href="/docs/using-queries"><span>Working With Queries</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#accessing-fields-on-a-type">Accessing Fields on a Type</a><ul class="toc-headings"><li><a href="#why-abstract-types">Why Abstract Types?</a></li></ul></li><li><a href="#nested-fields">Nested Fields</a></li><li><a href="#input-types">Input Types</a></li><li><a href="#enums">Enums</a></li><li><a href="#scalars">Scalars</a></li></ul></nav></div></div></body></html>